From 7f33cae310ddad32a12b58b32903443a68851c15 Mon Sep 17 00:00:00 2001
From: Ulf Samuelsson <ulf@emagii.com>
Date: Tue, 7 Feb 2023 19:21:00 +0100
Subject: [PATCH 3/4] Parse ASCIZ command

Signed-off-by: Ulf Samuelsson <ulf@emagii.com>
---
 ld/ldlang.c | 73 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 ld/ldlang.h |  4 +++
 2 files changed, 77 insertions(+)

diff --git a/ld/ldlang.c b/ld/ldlang.c
index 84a2914fc26..010e6e0fe22 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -8360,6 +8360,79 @@ lang_add_data (int type, union etree_union *exp)
   new_stmt->type = type;
 }
 
+void
+lang_add_string (bfd_vma size, char *s)
+{
+  lang_data_statement_type *new_stmt;
+  bfd_vma stringlen = strlen(s) + 1;    /* Add one for terminating '\0' */
+  bfd_vma fill_len = 0;
+  int     escape = 0;
+
+  if (size == 0) {  /* Zero terminated string */
+    size = stringlen;
+  } else if (size > stringlen) {    /* Fix Size string */
+    fill_len = size - stringlen;
+  } else if (size > stringlen) {
+    /* We have an error */
+    einfo (_("%P:%pS: warning: string does not fit \"%s\"\n"), NULL, s);
+  }
+  /* Add byte expressions until end of string */
+  for (bfd_vma i = 0 ; i < size ; i++) {
+    if (escape) {
+      char *p = &s[i];
+      char c = *p;
+      if (c == 't') {
+        *p = '\t';
+      } else if (c == 'n') {
+        *p = '\n';
+      } else if (c == 'r') {
+        *p = '\r';
+      } else if ((c >= '0') && (c <= '3')) {
+        int value = c;
+        c = p[1];
+        if ((c >= '0') && (c <= '7')) {
+          value <<= 3;
+          value += (c - '0');
+          i++;
+          c = p[2];
+          if ((c >= '0') && (c <= '7')) {
+            value <<= 3;
+            value += (c - '0');
+            i++;
+          }
+        }
+          s[i] = value;
+      } else {
+        /* whatever we have */
+      }
+      new_stmt = new_stat (lang_data_statement, stat_ptr);
+      new_stmt->exp = exp_intop(s[i]);
+      new_stmt->type = BYTE;
+      escape = 0;
+    } else {
+      if (s[i] == '\\') {
+        escape = 1;
+      } else {
+        new_stmt = new_stat (lang_data_statement, stat_ptr);
+        new_stmt->exp = exp_intop(s[i]);
+        new_stmt->type = BYTE;
+      }
+    }
+  }
+  /* Add byte expressions for filling to the end of the string */
+  for (bfd_vma i = 0 ; i < fill_len ; i++) {
+    new_stmt = new_stat (lang_data_statement, stat_ptr);
+    new_stmt->exp = exp_intop(0);
+    new_stmt->type = BYTE;
+  }
+}
+
+void
+lang_add_stringz (char *s)
+{
+    lang_add_string (0, s);
+}
+
 /* Create a new reloc statement.  RELOC is the BFD relocation type to
    generate.  HOWTO is the corresponding howto structure (we could
    look this up, but the caller has already done so).  SECTION is the
diff --git a/ld/ldlang.h b/ld/ldlang.h
index 24c42f48218..a77a4802e3e 100644
--- a/ld/ldlang.h
+++ b/ld/ldlang.h
@@ -646,6 +646,10 @@ extern void pop_stat_ptr
   (void);
 extern void lang_add_data
   (int type, union etree_union *);
+extern void
+lang_add_string (bfd_vma size, char *s);
+extern void
+lang_add_stringz (char *s);
 extern void lang_add_reloc
   (bfd_reloc_code_real_type, reloc_howto_type *, asection *, const char *,
    union etree_union *);
-- 
2.17.1

