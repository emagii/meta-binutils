From 2a2141e87f258c96a9f59c70dbb5e9a001a1bff0 Mon Sep 17 00:00:00 2001
From: Ulf Samuelsson <ulf@emagii.com>
Date: Fri, 10 Feb 2023 08:01:19 +0100
Subject: [PATCH 5/5] ASCII temp update

Signed-off-by: Ulf Samuelsson <ulf@emagii.com>
---
 ld/ldgram.y | 26 ++++++++++++++++++---
 ld/ldlang.c | 66 ++++++++++++++++++++++++++++++++++++++++++++++++++---
 ld/ldlang.h |  6 +++++
 ld/ldlex.l  |  3 +++
 4 files changed, 95 insertions(+), 6 deletions(-)

diff --git a/ld/ldgram.y b/ld/ldgram.y
index 4bbda989..194a0c2c 100644
--- a/ld/ldgram.y
+++ b/ld/ldgram.y
@@ -124,7 +124,7 @@ static int error_index;
 %right UNARY
 %token END
 %left <token> '('
-%token <token> ALIGN_K BLOCK BIND QUAD SQUAD LONG SHORT BYTE ASCII ASCIZ
+%token <token> ALIGN_K BLOCK BIND QUAD SQUAD LONG SHORT BYTE ASCII ASCIIE ASCII16 ASCII32 ASCIZ
 %token SECTIONS PHDRS INSERT_K AFTER BEFORE
 %token DATA_SEGMENT_ALIGN DATA_SEGMENT_RELRO_END DATA_SEGMENT_END
 %token SORT_BY_NAME SORT_BY_ALIGNMENT SORT_NONE
@@ -667,9 +667,29 @@ statement:
 		  lang_add_data ((int) $1, $3);
 		}
 
-	| ASCII INT ',' NAME
+/*
+	| ASCII '(' INT ')' NAME
+		{
+		  etree_type *size= exp_bigintop ($3.integer, $3.str);
+		  lang_add_string((bfd_vma) size->value.value, $5);
+		}
+*/
+	| ASCII INT
+		{
+		  etree_type *size= exp_bigintop ($2.integer, $2.str);
+		  lang_add_string((bfd_vma) size->value.value, "teststring");
+		}
+	| ASCIIE mustbe_exp ',' NAME
+		{
+		  lang_add_stringe($2, $4);
+		}
+	| ASCII16 NAME
+		{
+		  lang_add_string16($2);
+		}
+	| ASCII32 NAME
 		{
-		  lang_add_string($2.integer, $4);
+		  lang_add_string32($2);
 		}
 	| ASCIZ NAME
 		{
diff --git a/ld/ldlang.c b/ld/ldlang.c
index 1698cbbd..504026f2 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -8440,6 +8440,8 @@ lang_add_string (bfd_vma size, char *s)
   lang_data_statement_type *new_stmt;
   bfd_vma stringlen = strlen(s) + 1;    /* Add one for terminating '\0' */
   bfd_vma fill_len = 0;
+  int     escape = 0;
+
   if (size == 0) {  /* Zero terminated string */
     size = stringlen;
   } else if (size > stringlen) {    /* Fix Size string */
@@ -8450,9 +8452,46 @@ lang_add_string (bfd_vma size, char *s)
   }
   /* Add byte expressions until end of string */
   for (bfd_vma i = 0 ; i < size ; i++) {
-    new_stmt = new_stat (lang_data_statement, stat_ptr);
-    new_stmt->exp = exp_intop(s[i]);
-    new_stmt->type = BYTE;
+    if (escape) {
+        char *p = &s[i];
+        char c = *p;
+        if (c == 't') {
+            *p = '\t';
+        } else if (c == 'n') {
+            *p = '\n';
+        } else if (c == 'r') {
+            *p = '\r';
+        } else if ((c >= '0') && (c <= '3')) {
+            int value = c;
+            c = p[1];
+            if ((c >= '0') && (c <= '7')) {
+                value <<= 3;
+                value += (c - '0');
+                i++;
+                c = p[2];
+                if ((c >= '0') && (c <= '7')) {
+                    value <<= 3;
+                    value += (c - '0');
+                    i++;
+                }
+            }
+            s[i] = value;
+        } else {
+            /* whatever we have */
+        }
+        new_stmt = new_stat (lang_data_statement, stat_ptr);
+        new_stmt->exp = exp_intop(s[i]);
+        new_stmt->type = BYTE;
+        escape = 0;
+    } else {
+        if (s[i] == '\\') {
+            escape = 1;
+        } else {
+            new_stmt = new_stat (lang_data_statement, stat_ptr);
+            new_stmt->exp = exp_intop(s[i]);
+            new_stmt->type = BYTE;
+        }
+    }
   }
   /* Add byte expressions for filling to the end of the string */
   for (bfd_vma i = 0 ; i < fill_len ; i++) {
@@ -8468,6 +8507,27 @@ lang_add_stringz (char *s)
     lang_add_string (0, s);
 }
 
+void
+lang_add_string16 (char *s)
+{
+    lang_add_string (16, s);
+}
+
+void
+lang_add_string32 (char *s)
+{
+    lang_add_string (32, s);
+}
+
+void
+lang_add_stringe (union etree_union *exp, char *s)
+{
+    einfo (_("EXP TYPE:  \"%d\"\n"), exp->type.node_code);
+    einfo (_("EXP STRING:  \"%s\"\n"), s);
+    
+    lang_add_string (exp->value.value, s);
+}
+
 /* Create a new reloc statement.  RELOC is the BFD relocation type to
    generate.  HOWTO is the corresponding howto structure (we could
    look this up, but the caller has already done so).  SECTION is the
diff --git a/ld/ldlang.h b/ld/ldlang.h
index a170005b..f2e7fdf2 100644
--- a/ld/ldlang.h
+++ b/ld/ldlang.h
@@ -635,6 +635,12 @@ extern void
 lang_add_string (bfd_vma size, char *s);
 extern void
 lang_add_stringz (char *s);
+extern void
+lang_add_string16 (char *s);
+extern void
+lang_add_string32 (char *s);
+extern void
+lang_add_stringe (union etree_union *exp, char *s);
 extern void lang_add_reloc
   (bfd_reloc_code_real_type, reloc_howto_type *, asection *, const char *,
    union etree_union *);
diff --git a/ld/ldlex.l b/ld/ldlex.l
index 3ef33d2e..5711034f 100644
--- a/ld/ldlex.l
+++ b/ld/ldlex.l
@@ -310,6 +310,9 @@ V_IDENTIFIER [*?.$_a-zA-Z\[\]\-\!\^\\]([*?.$_a-zA-Z0-9\[\]\-\!\^\\]|::)*
 <WILD>"SHORT"				{ RTOKEN(SHORT); }
 <WILD>"BYTE"				{ RTOKEN(BYTE); }
 <WILD>"ASCII"				{ RTOKEN(ASCII); }
+<WILD>"ASCIIE"				{ RTOKEN(ASCIIE); }
+<WILD>"ASCII16"				{ RTOKEN(ASCII16); }
+<WILD>"ASCII32"				{ RTOKEN(ASCII32); }
 <WILD>"ASCIZ"				{ RTOKEN(ASCIZ); }
 <SCRIPT>"NOFLOAT"			{ RTOKEN(NOFLOAT); }
 <SCRIPT,EXPRESSION>"NOCROSSREFS"	{ RTOKEN(NOCROSSREFS); }
-- 
2.17.1

